"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pdfToPng = pdfToPng;
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const const_1 = require("./const");
const propsToPdfDocInitParams_1 = require("./propsToPdfDocInitParams");
const node_canvas_factory_1 = require("./node.canvas.factory");
/**
 * Converts a PDF file to PNG images.
 *
 * @param {string | Buffer} pdfFile - The path to the PDF file or a buffer containing the PDF data.
 * @param {PdfToPngOptions} [props] - Optional properties to customize the conversion process.
 * @param {number[]} [props.pagesToProcess] - An array of page numbers to process.
 * @param {string} [props.outputFolder] - The folder where the output PNG files will be saved.
 * @param {number} [props.viewportScale] - The scale to apply to the page viewport.
 * @param {(pageNumber: number) => string} [props.outputFileMaskFunc] - A function to generate custom file names for the output PNG files.
 * @param {boolean} [props.strictPagesToProcess] - Whether to throw an error if invalid pages are requested.
 * @returns {Promise<PngPageOutput[]>} A promise that resolves to an array of PNG page outputs.
 *
 * @throws Will throw an error if invalid pages are requested when `strictPagesToProcess` is true.
 *
 * @example
 * ```typescript
 * const pngPages = await pdfToPng('/path/to/pdf/file.pdf', {
 *   pagesToProcess: [1, 2, 3],
 *   outputFolder: '/path/to/output/folder',
 *   viewportScale: 2.0,
 *   outputFileMaskFunc: (pageNumber) => `custom_name_page_${pageNumber}.png`,
 * });
 * ```
 */
async function pdfToPng(pdfFile, props) {
    const isString = typeof pdfFile == "string";
    const pdfFileBuffer = isString ? (await node_fs_1.promises.readFile(pdfFile)).buffer : pdfFile;
    const pdfDocument = await getPdfDocument(pdfFileBuffer, props);
    // Get the pages to process based on the provided options, invalid pages will be filtered out
    const pagesToProcess = props?.pagesToProcess ?? Array.from({ length: pdfDocument.numPages }, (_, index) => index + 1);
    const validPagesToProcess = pagesToProcess.filter((pageNumber) => pageNumber <= pdfDocument.numPages && pageNumber >= 1);
    // Process each page in parallel
    const pngPagesOutput = [];
    try {
        // Process each page in parallel
        const pngPageOutputs = await Promise.all(validPagesToProcess
            // Filter out invalid page numbers
            .filter((pageNumber) => pageNumber <= pdfDocument.numPages && pageNumber >= 1)
            // Process the page
            .map((pageNumber) => {
            const pageViewportScale = props?.viewportScale !== undefined ? props.viewportScale : const_1.PDF_TO_PNG_OPTIONS_DEFAULTS.viewportScale;
            const defaultMask = isString ? (0, node_path_1.parse)(pdfFile).name : const_1.PDF_TO_PNG_OPTIONS_DEFAULTS.outputFileMask;
            const pageName = props?.outputFileMaskFunc?.(pageNumber) ?? `${defaultMask}_page_${pageNumber}.png`;
            return processPdfPage(pdfDocument, pageName, pageNumber, pageViewportScale);
        }));
        pngPagesOutput.push(...pngPageOutputs);
    }
    finally {
        await pdfDocument.cleanup();
    }
    // Save the PNG files to the output folder
    if (props?.outputFolder !== undefined) {
        await node_fs_1.promises.mkdir(props.outputFolder, { recursive: true });
        await Promise.all(pngPagesOutput.map(async (pngPageOutput) => {
            pngPageOutput.path = (0, node_path_1.resolve)(props.outputFolder, pngPageOutput.name);
            await node_fs_1.promises.writeFile(pngPageOutput.path, pngPageOutput.content);
        }));
    }
    return pngPagesOutput;
}
/**
 * Asynchronously retrieves a PDF document from a given ArrayBuffer.
 *
 * @param pdfFileBuffer - The buffer containing the PDF file data.
 * @param props - Optional properties to customize the PDF document initialization.
 * @param {number[]} [props.pagesToProcess] - An array of page numbers to process.
 * @param {string} [props.outputFolder] - The folder where the output PNG files will be saved.
 * @param {number} [props.viewportScale] - The scale to apply to the page viewport.
 * @param {(pageNumber: number) => string} [props.outputFileMaskFunc] - A function to generate custom file names for the output PNG files.
 * @param {boolean} [props.strictPagesToProcess] - Whether to throw an error if invalid pages are requested.
 * @returns A promise that resolves to a PDFDocumentProxy object representing the PDF document.
 */
async function getPdfDocument(pdfFileBuffer, props) {
    const { getDocument } = await import('pdfjs-dist/legacy/build/pdf.mjs');
    const documentInitParameters = (0, propsToPdfDocInitParams_1.propsToPdfDocInitParams)(props);
    return await getDocument({
        ...documentInitParameters,
        data: new Uint8Array(pdfFileBuffer),
    }).promise;
}
/**
 * Processes a single page of a PDF document and converts it to a PNG image.
 *
 * @param pdf - The PDF document proxy object representing the PDF document to be processed. This object provides methods to access the pages and other information about the PDF document.
 * @param pageName - The name to assign to the processed page.
 * @param pageNumber - The number of the page to process.
 * @param pageViewportScale - The scale to apply to the page viewport.
 * @returns A promise that resolves to an object containing the PNG image data and metadata.
 */
async function processPdfPage(pdf, pageName, pageNumber, pageViewportScale) {
    const page = await pdf.getPage(pageNumber);
    const viewport = page.getViewport({ scale: pageViewportScale });
    const canvasFactory = new node_canvas_factory_1.NodeCanvasFactory();
    const { canvas, context } = canvasFactory.create(viewport.width, viewport.height);
    await page.render({ canvasContext: context, viewport }).promise;
    const pngPageOutput = {
        pageNumber,
        name: pageName,
        content: canvas.toBuffer('image/png'),
        path: '',
        width: viewport.width,
        height: viewport.height,
    };
    page.cleanup();
    canvasFactory.destroy({ canvas, context });
    return pngPageOutput;
}
